name: flow
on:
  workflow_call:
    inputs:
      config:
        type: string
        description: config yaml
      image:
        type: string
        required: true
      build-group:
        type: string
        default: ubuntu-latest
      registry-user:
        type: string
    secrets:
      registry-pass: {}

env:
  sock: /var/run/docker.sock
  pass: ${{ secrets.registry-pass }}

jobs:
  build:
    runs-on: ${{ inputs.build-group }}
    steps:
      # if caller already called checkout, and this nested one creates undesirable latency
      # or other complications since i think it clears the working directory prior to checkout
      # it's possible to avoid this one here with use of cache at caller and uncache here,
      # but skipping that complexity for now...
      #
      - uses: actions/checkout@v3
      # login to setup creds registry, this will place creds in ~/.docker/config.json
      # so will need to share via volume to running container...
      #
      - run: echo ${pass} | docker login -u ${{ inputs.registry-user }} --password-stdin
        if: ${{ inputs.registry-user }} && ${pass}

      # required for called container to use docker
      #
      - run: sudo chmod o+rw ${sock}

      # run container with oci push logic
      #
      - run: |
          _cfg=$(pwd)/${{ inputs.config }}
          docker run --rm \
            -u $(id -u) -e HOME=${HOME}\
            -v $(pwd):$(pwd) -w $(pwd) \
            -v ${_cfg}:${_cfg} -e CONFIGR_YAML=${_cfg} \
            -v ${sock}:${sock} \
            -e DEBUG=dbg:* \
            ${{ inputs.image }}

      # docker logout to clean up creds for safe measure
      #
      - run: docker logout
        if: ${{ inputs.registry-user }} && ${pass}
